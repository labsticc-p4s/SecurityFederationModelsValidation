namespace "http://www.openflexo.org/projects/2024/1/ITrustMedicalSystem_1705498447306.prj" as ITRUSTMEDICALSYSTEM_1705498447306PRJ;
namespace "http://www.openflexo.org/projects/2024/1/ITrustMedicalSystemFederation_1705933420738.prj" as ITRUSTMEDICALSYSTEMFEDERATION_1705933420738PRJ;

use org.openflexo.technologyadapter.emf.EMFModelSlot as EMF;
use org.openflexo.foundation.fml.rt.FMLRTVirtualModelInstanceModelSlot as FMLRT;

import org.openflexo.technologyadapter.emf.model.EMFModel;
import org.openflexo.technologyadapter.emf.model.EMFObjectIndividual;
import java.lang.String;
import org.openflexo.foundation.ontology.IFlexoOntologyPropertyValue;
import java.util.List;

import ["http://www.omg.org/spec/BPMN/20100524/MODEL-XMI"] as BPMN21;

import ["http://www.example.org/deployementEcoreMetaModel"] as DEPLOYEMENT_ECORE_META_MODEL;
import ["http://www.eclipse.org/uml2/5.0.0/UML"] as UML2;

import [BPMN21:"Participant"] as BPMN_PARTICIPANT;
import [DEPLOYEMENT_ECORE_META_MODEL:"Artifact"] as DEPLOYMENT_ARTIFACT;
import [BPMN21:"MessageFlow"] as BPMN_MESSAGE_FLOW;
import [BPMN21:"TextAnnotation"] as BPMN_TEXT_ANNOTATION;
import [BPMN21:"Association"] as BPMN_ASSOCIATION;
import [BPMN21:"Process"] as BPMN_PROCESS;
import [BPMN21:"DataObject"] as BPMN_DATAOBJECT;
import [BPMN21:"FlowElement"] as BPMN_FLOW_ELEMENTS;
import [DEPLOYEMENT_ECORE_META_MODEL:"Deploy"] as DEPLOYMENT_DEPLOY;
import [DEPLOYEMENT_ECORE_META_MODEL:"Association"] as DEPLOYMENT_ASSOCIATION;
import [DEPLOYEMENT_ECORE_META_MODEL:"CommunicationPath"] as DEPLOYMENT_COMMUNICATION_PATH;
import ["http://www.eclipse.org/uml2/5.0.0/UML"] as UML22;
import [UML2:"Class"] as DATA_CLASS;
import [UML2:"Element"] as DATA_ELEMENT;
import ["AccessControlMetamodel"] as ACCESS_CONTROL_METAMODEL2;
import [ACCESS_CONTROL_METAMODEL2:"ROLE"] as ACCESS_CONTROL_ROLE;
import [ITRUSTMEDICALSYSTEMFEDERATION_1705933420738PRJ + "/ITrustSecurityFederation.fml"] as ITrustSecurityFederation;

typedef EMFObjectIndividualType(eClass=BPMN_PARTICIPANT) as BPMNParticipant;
typedef EMFObjectIndividualType(eClass=DEPLOYMENT_ARTIFACT) as DeploymentArtifact;
typedef EMFObjectIndividualType(eClass=DEPLOYMENT_COMMUNICATION_PATH) as DeploymentCommunicationPath;
typedef EMFObjectIndividualType(eClass=BPMN_MESSAGE_FLOW) as BPMNMessageFlow;
typedef EMFObjectIndividualType(eClass=DATA_CLASS) as DataClass;
typedef EMFObjectIndividualType(eClass=ACCESS_CONTROL_ROLE) as AccessControlRole;
typedef EMFObjectIndividualType(eClass=DATA_ELEMENT) as DataElement;
typedef EMFObjectIndividualType(eClass=BPMN_DATAOBJECT) as BPMNDataObject;
typedef EMFObjectIndividualType(eClass=BPMN_ASSOCIATION) as BPMNAssociation;
typedef EMFObjectIndividualType(eClass=BPMN_FLOW_ELEMENTS) as BPMNFlowElements;
typedef EMFObjectIndividualType(eClass=BPMN_TEXT_ANNOTATION) as BPMNTextAnnotation;
typedef EMFObjectIndividualType(eClass=DEPLOYMENT_ASSOCIATION) as DeploymentAssociation;
typedef EMFObjectIndividualType(eClass=DEPLOYMENT_DEPLOY) as DeploymentDeploy;

@URI("http://www.openflexo.org/projects/2024/1/ITrustMedicalSystemFederation_1705933420738.prj/ITrustSecurityFederation.fml")
@Author("chahr")
public model ITrustSecurityFederation {
	EMFModel bpmnModelAccess with EMFModelSlot(metaModel=BPMN21,isRequired=true);
	EMFModel deploymentModelAccess with EMFModelSlot(metaModel=DEPLOYEMENT_ECORE_META_MODEL,isRequired=true);
	EMFModel accessControlModelAccess with EMFModelSlot(metaModel=ACCESS_CONTROL_METAMODEL2,isRequired=true);
	EMFModel dataModelAccess with EMFModelSlot(metaModel=UML2,isRequired=true);
	
	MessageFlowCommunicationPathCorrepondence[0,*] listInstancesMessageComm with ConceptInstance(virtualModelInstance=this);
	PoolArtifactCorrespondence[0,*] listInstancesPoolArtifact with ConceptInstance(virtualModelInstance=this);
     UserRoleCorrespondence[0,*] listUserRoleLink with ConceptInstance(virtualModelInstance=this);


	public create::createAccessObject(required Resource<EMFModel> bpmnModelResource, required Resource<EMFModel> deploymentModelResource, required Resource<EMFModel> dataModelResource, required Resource<EMFModel> accessControlModelResource) {
      	bpmnModelAccess = parameters.bpmnModelResource.resourceData;
          deploymentModelAccess = parameters.deploymentModelResource.resourceData;
          dataModelAccess = parameters.dataModelResource.resourceData;
    		accessControlModelAccess = parameters.accessControlModelResource.resourceData;
      }


	// Join all the instances of the concept MessageFlowCommunicationPath
     private joinInstanceMessageFlowCommnicationPath() {
		for (MessageFlowCommunicationPathCorrepondence item :select MessageFlowCommunicationPathCorrepondence from this) {
			if (!listInstancesMessageComm.contains(item)) {
			listInstancesMessageComm.add(item);	
			}	
		}
     }


     // Verify whether an artifact is a part of the PoolArtifactCorrespondence intance and return the artifact 
	private  List<DeploymentArtifact> verifyExistenceCorresp(List<String> artifacts) {
		List<DeploymentArtifact>	listArtifact  = new ArrayList<DeploymentArtifact>();
		 	for (PoolArtifactCorrespondence item : select PoolArtifactCorrespondence from this ) {
		 		if (parameters.artifacts.contains(item.artifact.name.toString)) {
					listArtifact.add(item.artifact);
				}	
	 		}
	 	return listArtifact;
	}


    //  Retrieve the list of Pools related to an Artifact selected 
	private BPMNParticipant getPool(DeploymentArtifact artifact) {
		BPMNParticipant associatedPool; 
	 	for (PoolArtifactCorrespondence item : select PoolArtifactCorrespondence from this) {
			if (item.artifact == parameters.artifact) {
				associatedPool = item.pool;
			}
	 	}
	 	return associatedPool;
	}

	delete() {

	}
	
	
 	//  Check if the user has a valid role 
	private boolean checkUserRole(required String userName) {
	    boolean checked = false;
	   // List<UserRoleCorrespondence> links =select UserRoleCorrespondence from this ;
	    for (UserRoleCorrespondence item : select UserRoleCorrespondence from this) {
	        if (item.user.name == parameters.userName && item.verifyCorrespondence()) {
	            checked = true;
	        }
	    }
	    
	    return checked;
	}
	

	// Check the security annotations of the flowelements
	private boolean checkDataObjectAnnotations(BPMNFlowElements flowElements) {
		for (BPMNAssociation itemAsso : select BPMNAssociation from bpmnModelAccess) {
			for (BPMNTextAnnotation itemAnnota : select BPMNTextAnnotation from bpmnModelAccess ) {
				if (parameters.flowElements == itemAsso.sourceRef && itemAnnota == itemAsso.targetRef) {
					if (itemAnnota.text.contains("IntegrityDo") || itemAnnota.text.contains("ConfidentialityDo") || itemAnnota.text.contains("PrivacyDo")) {
						return true;
					} 
else {
						return false;
					}
				}
			}
		}					
	} 

	// Get the FlowElements of a selected Pool
	private List<BPMNFlowElements> getFlowElementsOfPool(BPMNParticipant pool) {
		List<BPMNFlowElements> listFlowElements = new ArrayList<BPMNFlowElements>();
		for (BPMNParticipant itemParticipant : select BPMNParticipant from  bpmnModelAccess) {
			if (itemParticipant == parameters.pool) { 
				for (BPMNFlowElements itemFlows : select BPMNFlowElements from bpmnModelAccess) {
					if (itemParticipant.processRef.flowElements.contains(itemFlows) && itemFlows instanceof BPMNDataObject) {
						listFlowElements.add(itemFlows);
					}
				}
			}
		}
		
		return listFlowElements;
	}

	// Verify the security annotations of a DataObject included in the FlowElements 
	private boolean verifyDataObjectAnnotation(List<BPMNFlowElements> listFlowElements) {
		for (BPMNFlowElements itemFlowElements : parameters.listFlowElements) {
			for (BPMNAssociation itemAsso : select BPMNAssociation from bpmnModelAccess) {
				for (BPMNTextAnnotation itemAnnota : select BPMNTextAnnotation from bpmnModelAccess ) {
					if (itemFlowElements == itemAsso.sourceRef && itemAnnota == itemAsso.targetRef) {
						if (itemAnnota.text.contains("IntegrityDo") || itemAnnota.text.contains("ConfidentialityDo") || itemAnnota.text.contains("PrivacyDo")) {
							return true;
						}
					}
				}
			}
		}
		
		return false;
	}
	
	// Verify if an artifact has association with other artifacts in the Deployment model
	private List<String> verifyExistenceArtifactAssociated(DeploymentArtifact artifact) {
		boolean existe = false;
		List<String> listAssoArtifact = new ArrayList<String>();
		for (DeploymentAssociation itemAsso : select DeploymentAssociation from deploymentModelAccess) {
			for (Object itemArtifact : itemAsso.getValues("artifact")) {
				if (itemArtifact == parameters.artifact) {
					existe = true;
				} 
else {
					existe = false;
				}
			}
			if (existe) {
				for (Object itemArtifact : itemAsso.getValues("artifact")) {
					if (!(itemArtifact == parameters.artifact)) {
						listAssoArtifact.add(itemArtifact.toString.substring(9).toString);
					}
				}
			}
		}
		return listAssoArtifact;
	}

	// Get the device where an artifact is deployed
	private List<EMFObjectIndividual> getDeploymentArtifact(DeploymentArtifact artifact) {
	List<EMFObjectIndividual> devicesArtifact = new ArrayList<EMFObjectIndividual>();
		for (DeploymentDeploy itemDeploy : select DeploymentDeploy from deploymentModelAccess) {
			if (itemDeploy.artifact == parameters.artifact) {
				if (itemDeploy.device != null) {
					devicesArtifact.add(itemDeploy.device);
				} 
else {
					if (itemDeploy.node != null) {
						devicesArtifact.add(itemDeploy.node);
					}
				}
			}
		}
		return devicesArtifact;
	}

	// Get communicationPath for a selected device
	private List<DeploymentCommunicationPath> getCommunicationPath(List<EMFObjectIndividual> devices) {
		List<DeploymentCommunicationPath> commPath = new ArrayList<DeploymentCommunicationPath>();
		for (DeploymentCommunicationPath commPath1 : select DeploymentCommunicationPath from deploymentModelAccess) {
			if (parameters.devices.contains(commPath1.device)) {
				commPath.add(commPath1);
			}
		}
		return commPath;
	}

	// verify if the artifact and the associated artifacts are deployed in the same devices
	private boolean verifyDeploy(List<EMFObjectIndividual> deviceArtifact, List<EMFObjectIndividual> devicesAssoArtifact) {
		for (EMFObjectIndividual device : parameters.deviceArtifact) {
			if (!parameters.devicesAssoArtifact.contains(device)) {
				return false;
			}
		}
		return true;
	}

	// Get MessageFlow for a selected Pool 
	private List<BPMNMessageFlow> getMessageFlows(EMFObjectIndividual pool) {
		List<BPMNMessageFlow> messageFlows = new ArrayList<BPMNMessageFlow>();
		for (BPMNParticipant parti : select BPMNParticipant from  bpmnModelAccess) {
			if (parti.id.toString == parameters.pool.name.toString) {
				int n = parti.processRef.flowElements.size();
				for ( BPMNMessageFlow dataflow : select BPMNMessageFlow  from  bpmnModelAccess ) { 
					for (int j=0 ; j < n ; j++) {
						if (dataflow.sourceRef.toString == parti.processRef.flowElements.get(j).toString) {
							messageFlows.add(dataflow);
						}
						if (dataflow.targetRef.toString == parti.processRef.flowElements.get(j).toString) {
							messageFlows.add(dataflow);
						}
					}
				}
			}
		}
		return messageFlows;
	}

	// Get MessageFlows shared between two Pools
	private List<BPMNMessageFlow> getSharedMessageFlows(List<BPMNMessageFlow> messageFlowsPool, List<BPMNMessageFlow> messageFlowsAssociatedPool) {
		List<BPMNMessageFlow> sharedMessageFlows = new ArrayList<BPMNMessageFlow>();
		for (BPMNMessageFlow messageflow : parameters.messageFlowsAssociatedPool) {
			if (parameters.messageFlowsPool.contains(messageflow)) {
				sharedMessageFlows.add(messageflow);
			}
		}

		return sharedMessageFlows; 
	}

	private boolean checkSecurityAnnotaionsOnAssociation(DeploymentArtifact artifact) {
      boolean check = false;
      for (DeploymentAssociation association : select DeploymentAssociation from deploymentModelAccess) {
         if (association.getValues("artifact").toString.contains(parameters.artifact.nameArtifact)) {
            if (association.getValues("secrecy") != null || association.getValues("integrity") != null) {
               check = true;
            }
         }
       }
      return check;
	}

  private boolean ckeckSecurityAnnotationOnCommunicationPath(DeploymentArtifact artifact) {
    boolean check = false;
      for (DeploymentDeploy deploy : select DeploymentDeploy from deploymentModelAccess) {
         if (deploy.getValues("artifact").toString.contains(parameters.artifact.nameArtifact)) {
            for (DeploymentCommunicationPath path : select DeploymentCommunicationPath from deploymentModelAccess) {
               if (path.getValues("node").toString.contains(deploy.node.nameNode) && path.getValues("encrypted") != null) {
                  check = true;
               }
            }
         }
      }
   
   return check; 
  }

    public concept Correspondences {
    	
	// The correspondence between a Pool in the BPMN model and an artifact in the Deployment model  
	public concept PoolArtifactCorrespondence extends Correspondences {
		BPMNParticipant pool with EMFObjectRole(container=bpmnModelAccess,type=BPMN_PARTICIPANT);
		DeploymentArtifact artifact with EMFObjectRole(container=deploymentModelAccess,type=DEPLOYMENT_ARTIFACT);
		
		MessageFlowCommunicationPathCorrepondence[0,*] listInstancesMessageComm with ConceptInstance(virtualModelInstance=container.container);

		// create the instance of the concept with the selected pool and artifact
		create::_create(required String name) {
			pool = select unique BPMNParticipant from bpmnModelAccess where (selected.name == parameters.name);
			artifact = select unique DeploymentArtifact from deploymentModelAccess where (selected.name == parameters.name);
		}
		delete() {
			delete pool;
			delete artifact;
		}
		

	// --- iTrust security Rule1 --- 
	/*  this security verify when two Pools in the BPMN model (that correspond to artifacts in the deployment model), communicate security-critical data and
	are deployed in different devices, the communication between the two devices must occur through an encrypted channel. This rule is added to the
	concept PoolArtifactCorrespondence  */
	
	public void iTrustSecurityRule1() {
		boolean checkConfidentialData = false;
		List<BPMNFlowElements> flowElts = new ArrayList<BPMNFlowElements>();
		
		// Get instance of the Concept MessageFlowCommunicatioPath
		container.container.joinInstanceMessageFlowCommnicationPath();
		listInstancesMessageComm = container.container.listInstancesMessageComm; 
		flowElts = container.container.getFlowElementsOfPool(pool);
		checkConfidentialData  = container.container.verifyDataObjectAnnotation(flowElts);
		// This security rule request to verify the securityRule2 
		if (checkConfidentialData == true && !this.verifyExistenceConsistentInstance()) {
			log "Security rule violated";
		} 
else {
			log "Security rule not violated";
		}
	}
		

	private boolean verifyExistenceConsistentInstance() {
		List<EMFObjectIndividual> assoPool;
		List<EMFObjectIndividual> commPath;
		List<DeploymentArtifact>	assoArtifactsFilter  = new ArrayList<DeploymentArtifact>();
		List<String> assoArtifacts  = new ArrayList<String>();
		List<EMFObjectIndividual> devices = new ArrayList<EMFObjectIndividual>();
		List<EMFObjectIndividual> devicesArtifactsFilter = new ArrayList<EMFObjectIndividual>();
		List<DeploymentCommunicationPath> commPath = new ArrayList<DeploymentCommunicationPath>();
		List<BPMNMessageFlow> messageFlowsPool = new ArrayList<BPMNMessageFlow>();
		List<BPMNMessageFlow> messageFlowsAssociatedPool = new ArrayList<BPMNMessageFlow>();
		List<BPMNMessageFlow> sharedMessageFlows = new ArrayList<BPMNMessageFlow>();
		BPMNParticipant associatedPool;
		
		// Get associated artifacts
		assoArtifacts = container.container.verifyExistenceArtifactAssociated(artifact);
		assoArtifactsFilter = container.container.verifyExistenceCorresp(assoArtifacts);
		
		// Get Devices where the Artifact is deployed
		devices = container.container.getDeploymentArtifact(artifact);
		commPath = container.container.getCommunicationPath(devices);

		// Get MessageFlow outgoing from Pool to the associated Pool
		for (DeploymentArtifact assoArtifactFilt : assoArtifactsFilter) {
			associatedPool = container.container.getPool(assoArtifactFilt);
			devicesArtifactsFilter = container.container.getDeploymentArtifact(assoArtifactFilt); 
			if (!container.container.verifyDeploy(devices,devicesArtifactsFilter)) {
				messageFlowsPool = container.container.getMessageFlows(pool);
				messageFlowsAssociatedPool = container.container.getMessageFlows(associatedPool);
				sharedMessageFlows = container.container.getSharedMessageFlows(messageFlowsPool,messageFlowsAssociatedPool);
				for (BPMNMessageFlow dataflow : sharedMessageFlows) {
					// Verify the security rule 2
					for (MessageFlowCommunicationPathCorrepondence item : container.container.listInstancesMessageComm) {
						if (dataflow == item.messageFlow && commPath.contains(item.communicationPath)) {
							if (!item.verifySecureCommunication()) {
								return false; 
							}
						}
					}
				}
			}
		}
		return true;
	}
}

	public concept MessageFlowCommunicationPathCorrepondence extends Correspondences {
		BPMNMessageFlow messageFlow with EMFObjectRole(container=bpmnModelAccess,type=BPMN_MESSAGE_FLOW);
		DeploymentCommunicationPath communicationPath with EMFObjectRole(container=deploymentModelAccess,type=DEPLOYMENT_COMMUNICATION_PATH);
		
		create::_create(required String nameMessage, required String nameCommPath) {
			messageFlow = select unique BPMNMessageFlow from bpmnModelAccess where (selected.name == parameters.nameMessage);
			communicationPath = select unique DeploymentCommunicationPath from deploymentModelAccess where (selected.name == parameters.nameCommPath);
		}

		// --- iTrust security Rule2 --- 
		/* This security rule check if the communicationPath in the BPMN model correponding to MessageFlow in the BPMN model 
		has semantically the same secuirty annotation  */

		public iTrustSecurityRule2() {
			boolean check = false;
			check = this.verifySecureCommunication();
			if (check) {
				log "Security rule verified";
			} 
else {
				log "Security rule violated";
			}
			
		}

		// Verify if the communicationPath is encypted and MessageFlow contains at least one of these security annotations(NonRepudMF, ConfidentialityMF, IntegrityMF)
		private boolean verifySecureCommunication() {
			boolean check = false;
			List<? extends Object> encrypted = communicationPath.getValues("encrypted");
			for (BPMNAssociation asso : select BPMNAssociation from bpmnModelAccess) {
				if (asso.targetRef == messageFlow.toString.substring(12)) {
					for (BPMNTextAnnotation annota : select BPMNTextAnnotation from  bpmnModelAccess) {
						if (asso.sourceRef.id == annota.id) {
							if (encrypted != null && (annota.text.contains("NonRepudMF") || annota.text.contains("ConfidentialityMF") || annota.text.contains("IntegrityMF"))) {
								check = true;
							} 
else {
								check = false;
							}
						}
					}
				}
			}
			return check;
		}



		
		delete() {
			delete messageFlow;
			delete communicationPath;
		}
	}

	public concept UserRoleCorrespondence extends Correspondences{
		DataClass user with EMFObjectRole(container=dataModelAccess,type=DATA_CLASS);
		AccessControlRole role with EMFObjectRole(container=accessControlModelAccess,type=ACCESS_CONTROL_ROLE);
		
		create::_create(required String roleName, required String userName) {
			user = select unique DataClass from dataModelAccess where (selected.name == parameters.userName);
			role = select unique AccessControlRole from accessControlModelAccess where (selected.name == parameters.roleName);
		}
		delete() {
		}
		
		// --- iTrust security Rule3 ---
		/*  This security rule check if the user in the Data model correponds to a role in the AccessControl model 
		or this user inherit from other users that have a role   */
		
		public void iTrustSecurityRule3(required String nameUser) {
			boolean checked = false;
			boolean checkedInherit = false;

			// Verify if the instances of the concept UserRoleCorrespondence include the selected user
			checked = container.container.checkUserRole(parameters.nameUser);
			if (!checked) {
				// Whether no, verify if the instances of the concept UserRoleCorrespondence include the inheriting user
				for (DataClass itemUser : select DataClass from dataModelAccess) {
					if (itemUser.getValues("member").toString.contains(parameters.nameUser) && container.container.checkUserRole(itemUser.name)) {
						checkedInherit = true;
					}
				}
			}
			// Notify the user 
			if (checkedInherit) {
				log "Security rule verified";
			}
			else {
				log "Security rule violated";
			}
		}
		
		/*  These function verify whether the user and the role is not null 
		 for an isntance of UserRoleCorreponeces  */
		 
		private boolean verifyCorrespondence() {
				if (user == null || role == null) {
					return false;
				} 
else {
					return true;
				}
		}
	}

	public concept PoolClassCorrespondence extends Correspondences{
		
		BPMNParticipant pool with EMFObjectRole(container=bpmnModelAccess,type=BPMN_PARTICIPANT);
		DataClass class with EMFObjectRole(container=dataModelAccess,type=DATA_CLASS);

		create::_create(required String poolName, required String className) {
			pool = select unique BPMNParticipant from bpmnModelAccess where (selected.name == parameters.poolName);
			class = select unique DataClass from dataModelAccess where (selected.name == parameters.className);
			
		}

		// --- iTrust security Rule4 --- 
		/*  This security rule checks if the Pool in the BPMN model contains a confidential DataObject,
		 the corresponding Class must have semantically the same security annotations  */
		       
		public iTrustSecurityRule4() {
			boolean checkConfidentialDataObject = false;
			List<BPMNFlowElements> listFlowElements = new ArrayList<BPMNFlowElements>();
			
			// Get all FlowElements for the selected pool 
			listFlowElements = container.container.getFlowElementsOfPool(pool);
			
			// Verify if there are confidential DataObjects between the FlowElements.
			checkConfidentialDataObject = container.container.verifyDataObjectAnnotation(listFlowElements);
			
			// Verify whether the corresponding class has the security annotation 'Critical' when the Pool contains a confidential DataObject.
			if (checkConfidentialDataObject && class.getValues("member").toString.contains("Critical") ) {
				log "Security rule verified";
			} 
else {
				log "Security rule violated";
			}

		}
	}	}

   public concept ClassArtifactCorrespondence extends Correspondences {
       DataClass class with EMFObjectRole(container=dataModelAccess,type=DATA_CLASS);
       DeploymentArtifact artifact with EMFObjectRole(container=deploymentModelAccess,type=DEPLOYMENT_ARTIFACT);

       create::_create(required String className, required String artifactName) {
         class = select unique DataClass from dataModelAccess where (selected.name == parameters.className);
         artifact = select unique DeploymentArtifact from deploymentModelAccess where (selected.name == parameters.artifactName);
      }

       // --- iTrust security Rule5 ---
       /*   when a Class in the Data model (that corresponds to artifact in the deployment model deployed in device), contains security
         annotation “Critical”. The communication Path between the corresponding device must be encrypted */
         
        public iTrustSecurityRule5() {
           boolean checkAnnotation = container.container.ckeckSecurityAnnotationOnCommunicationPath(artifact); 
           if (class.getValues("nestedClassifier").toString.contains("Critical") && checkAnnotation) {
               log "Security rule verified";
           } 
else {
               log "Security rule violated";
           }
         }
        
   
          // --- iTrust security Rule6 ---
          /* when a class in the data model (that correspond to artifact in the deployment model) annotated "Critical". the associations relating 
           this artifact with other must to be annotated Secrecy or Integrity */
           
         public iTrustSecurityRule6() {
            boolean checkAnnotation = container.container.checkSecurityAnnotaionsOnAssociation(artifact);
            if (class.getValues("nestedClassifier").toString.contains("Critical") && checkAnnotation) {
               log "Security rule verified";
            } 
else {
               log "Security rule violated";
            }
         }   
   }

  
    }
	
}
